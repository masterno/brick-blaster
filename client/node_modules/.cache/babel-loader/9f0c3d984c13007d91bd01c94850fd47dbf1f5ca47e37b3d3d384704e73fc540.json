{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useCallback, useRef } from 'react';\nimport LevelManager from './LevelManager';\nexport const useGameLoop = (initialLives = 3) => {\n  _s();\n  const [isRunning, setIsRunning] = useState(false);\n  const [isPaused, setIsPaused] = useState(false);\n  const [currentLevel, setCurrentLevel] = useState(1);\n  const [score, setScore] = useState(0);\n  const [lives, setLives] = useState(initialLives);\n  const [isGameOver, setIsGameOver] = useState(false);\n  const [isVictory, setIsVictory] = useState(false);\n  const levelManagerRef = useRef(new LevelManager());\n  const animationFrameIdRef = useRef(null);\n  const lastTimeRef = useRef(0);\n  const loadLevel = useCallback(gameObjects => {\n    const levelData = levelManagerRef.current.loadLevel(currentLevel);\n    gameObjects.bricks = levelData.bricks;\n    if (gameObjects.ball) {\n      gameObjects.ball.setSpeed(levelData.speed); // Use level speed directly\n    }\n    return levelData;\n  }, [currentLevel]);\n  const resetGame = useCallback(gameObjects => {\n    setCurrentLevel(1);\n    setScore(0);\n    setLives(initialLives);\n    setIsGameOver(false);\n    setIsVictory(false);\n    if (gameObjects.ball) gameObjects.ball.reset();\n    if (gameObjects.paddle) gameObjects.paddle.reset();\n    loadLevel(gameObjects);\n  }, [initialLives, loadLevel]);\n  const handleBallOut = useCallback(gameObjects => {\n    setLives(prev => {\n      const newLives = prev - 1;\n      if (newLives <= 0) {\n        setIsGameOver(true);\n        setIsVictory(false);\n        stop();\n      }\n      return newLives;\n    });\n\n    // Reset ball and paddle position if game isn't over\n    if (lives > 1) {\n      gameObjects.ball.reset();\n      gameObjects.paddle.reset();\n    }\n  }, [lives]);\n  const update = useCallback((ctx, gameObjects) => {\n    const {\n      ball,\n      paddle,\n      bricks = []\n    } = gameObjects;\n\n    // Clear canvas\n    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n\n    // Update game objects\n    ball.update();\n    paddle.update();\n\n    // Check if ball is out\n    if (ball.y + ball.radius > ctx.canvas.height) {\n      handleBallOut(gameObjects);\n      return;\n    }\n\n    // Check paddle collision\n    if (ball.checkCollision(paddle)) {\n      ball.bounceOffPaddle(paddle);\n    }\n\n    // Check brick collisions\n    bricks.forEach((brick, index) => {\n      if (!brick.broken && brick.checkCollision(ball)) {\n        ball.bounceOffBrick(brick);\n        if (brick.hit()) {\n          // Handle brick destruction\n          if (brick.type === 'explosive') {\n            // Destroy adjacent bricks\n            bricks.forEach(otherBrick => {\n              if (!otherBrick.broken && Math.abs(otherBrick.x - brick.x) <= brick.width * 2 && Math.abs(otherBrick.y - brick.y) <= brick.height * 2) {\n                otherBrick.broken = true;\n                setScore(prev => prev + 100);\n              }\n            });\n          }\n          setScore(prev => prev + (brick.type === 'durable' ? 150 : 100));\n        }\n      }\n    });\n\n    // Check if level is complete\n    if (levelManagerRef.current.isLevelComplete(bricks)) {\n      if (currentLevel < levelManagerRef.current.getMaxLevel()) {\n        setCurrentLevel(prev => prev + 1);\n        loadLevel(gameObjects);\n        // Reset ball and paddle position\n        ball.reset();\n        paddle.reset();\n      } else {\n        // Game complete - Victory!\n        setIsGameOver(true);\n        setIsVictory(true);\n        stop();\n      }\n    }\n\n    // Draw game objects\n    bricks.forEach(brick => brick.draw(ctx));\n    ball.draw(ctx);\n    paddle.draw(ctx);\n\n    // Draw HUD\n    drawHUD(ctx);\n  }, [currentLevel, handleBallOut, loadLevel]);\n  const drawHUD = useCallback(ctx => {\n    ctx.font = '16px Arial';\n    ctx.fillStyle = '#FFFFFF';\n    ctx.textAlign = 'left';\n    ctx.fillText(`Score: ${score}`, 10, 20);\n    ctx.fillText(`Level: ${currentLevel}`, 10, 40);\n\n    // Draw lives\n    ctx.textAlign = 'right';\n    ctx.fillText(`Lives: ${lives}`, ctx.canvas.width - 10, 20);\n  }, [score, currentLevel, lives]);\n  const gameLoop = useCallback((ctx, gameObjects) => {\n    if (!isRunning) return;\n    const currentTime = performance.now();\n    const deltaTime = (currentTime - lastTimeRef.current) / 1000;\n    lastTimeRef.current = currentTime;\n    update(ctx, gameObjects, deltaTime);\n    animationFrameIdRef.current = window.requestAnimationFrame(() => gameLoop(ctx, gameObjects));\n  }, [isRunning, update]);\n  const start = useCallback((ctx, gameObjects) => {\n    setIsRunning(true);\n    setIsPaused(false);\n    lastTimeRef.current = performance.now();\n    loadLevel(gameObjects);\n    gameLoop(ctx, gameObjects);\n  }, [gameLoop, loadLevel]);\n  const stop = useCallback(() => {\n    setIsRunning(false);\n    setIsPaused(false);\n    if (animationFrameIdRef.current) {\n      window.cancelAnimationFrame(animationFrameIdRef.current);\n      animationFrameIdRef.current = null;\n    }\n  }, []);\n  const pause = useCallback(() => {\n    setIsPaused(true);\n  }, []);\n  const resume = useCallback(() => {\n    setIsPaused(false);\n  }, []);\n  return {\n    start,\n    stop,\n    pause,\n    resume,\n    score,\n    currentLevel,\n    lives,\n    isRunning,\n    isPaused,\n    isGameOver,\n    isVictory,\n    setIsRunning,\n    setIsPaused,\n    setIsGameOver,\n    setIsVictory,\n    setCurrentLevel,\n    setScore,\n    setLives,\n    resetGame,\n    loadLevel,\n    handleBallOut\n  };\n};\n_s(useGameLoop, \"i3s8PGmtardWhozItTAlCBC68rQ=\");\nexport default useGameLoop;","map":{"version":3,"names":["useState","useCallback","useRef","LevelManager","useGameLoop","initialLives","_s","isRunning","setIsRunning","isPaused","setIsPaused","currentLevel","setCurrentLevel","score","setScore","lives","setLives","isGameOver","setIsGameOver","isVictory","setIsVictory","levelManagerRef","animationFrameIdRef","lastTimeRef","loadLevel","gameObjects","levelData","current","bricks","ball","setSpeed","speed","resetGame","reset","paddle","handleBallOut","prev","newLives","stop","update","ctx","clearRect","canvas","width","height","y","radius","checkCollision","bounceOffPaddle","forEach","brick","index","broken","bounceOffBrick","hit","type","otherBrick","Math","abs","x","isLevelComplete","getMaxLevel","draw","drawHUD","font","fillStyle","textAlign","fillText","gameLoop","currentTime","performance","now","deltaTime","window","requestAnimationFrame","start","cancelAnimationFrame","pause","resume"],"sources":["C:/Users/noahm/OneDrive/Desktop/Coding/brick_blaster2/client/src/components/Game/GameLoop.js"],"sourcesContent":["import { useState, useCallback, useRef } from 'react';\nimport LevelManager from './LevelManager';\n\nexport const useGameLoop = (initialLives = 3) => {\n  const [isRunning, setIsRunning] = useState(false);\n  const [isPaused, setIsPaused] = useState(false);\n  const [currentLevel, setCurrentLevel] = useState(1);\n  const [score, setScore] = useState(0);\n  const [lives, setLives] = useState(initialLives);\n  const [isGameOver, setIsGameOver] = useState(false);\n  const [isVictory, setIsVictory] = useState(false);\n  const levelManagerRef = useRef(new LevelManager());\n  const animationFrameIdRef = useRef(null);\n  const lastTimeRef = useRef(0);\n\n  const loadLevel = useCallback((gameObjects) => {\n    const levelData = levelManagerRef.current.loadLevel(currentLevel);\n    gameObjects.bricks = levelData.bricks;\n    if (gameObjects.ball) {\n      gameObjects.ball.setSpeed(levelData.speed); // Use level speed directly\n    }\n    return levelData;\n  }, [currentLevel]);\n\n  const resetGame = useCallback((gameObjects) => {\n    setCurrentLevel(1);\n    setScore(0);\n    setLives(initialLives);\n    setIsGameOver(false);\n    setIsVictory(false);\n    if (gameObjects.ball) gameObjects.ball.reset();\n    if (gameObjects.paddle) gameObjects.paddle.reset();\n    loadLevel(gameObjects);\n  }, [initialLives, loadLevel]);\n\n  const handleBallOut = useCallback((gameObjects) => {\n    setLives(prev => {\n      const newLives = prev - 1;\n      if (newLives <= 0) {\n        setIsGameOver(true);\n        setIsVictory(false);\n        stop();\n      }\n      return newLives;\n    });\n\n    // Reset ball and paddle position if game isn't over\n    if (lives > 1) {\n      gameObjects.ball.reset();\n      gameObjects.paddle.reset();\n    }\n  }, [lives]);\n\n  const update = useCallback((ctx, gameObjects) => {\n    const { ball, paddle, bricks = [] } = gameObjects;\n    \n    // Clear canvas\n    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n    \n    // Update game objects\n    ball.update();\n    paddle.update();\n    \n    // Check if ball is out\n    if (ball.y + ball.radius > ctx.canvas.height) {\n      handleBallOut(gameObjects);\n      return;\n    }\n    \n    // Check paddle collision\n    if (ball.checkCollision(paddle)) {\n      ball.bounceOffPaddle(paddle);\n    }\n\n    // Check brick collisions\n    bricks.forEach((brick, index) => {\n      if (!brick.broken && brick.checkCollision(ball)) {\n        ball.bounceOffBrick(brick);\n        if (brick.hit()) {\n          // Handle brick destruction\n          if (brick.type === 'explosive') {\n            // Destroy adjacent bricks\n            bricks.forEach(otherBrick => {\n              if (!otherBrick.broken && \n                  Math.abs(otherBrick.x - brick.x) <= brick.width * 2 && \n                  Math.abs(otherBrick.y - brick.y) <= brick.height * 2) {\n                otherBrick.broken = true;\n                setScore(prev => prev + 100);\n              }\n            });\n          }\n          setScore(prev => prev + (brick.type === 'durable' ? 150 : 100));\n        }\n      }\n    });\n    \n    // Check if level is complete\n    if (levelManagerRef.current.isLevelComplete(bricks)) {\n      if (currentLevel < levelManagerRef.current.getMaxLevel()) {\n        setCurrentLevel(prev => prev + 1);\n        loadLevel(gameObjects);\n        // Reset ball and paddle position\n        ball.reset();\n        paddle.reset();\n      } else {\n        // Game complete - Victory!\n        setIsGameOver(true);\n        setIsVictory(true);\n        stop();\n      }\n    }\n    \n    // Draw game objects\n    bricks.forEach(brick => brick.draw(ctx));\n    ball.draw(ctx);\n    paddle.draw(ctx);\n\n    // Draw HUD\n    drawHUD(ctx);\n  }, [currentLevel, handleBallOut, loadLevel]);\n\n  const drawHUD = useCallback((ctx) => {\n    ctx.font = '16px Arial';\n    ctx.fillStyle = '#FFFFFF';\n    ctx.textAlign = 'left';\n    ctx.fillText(`Score: ${score}`, 10, 20);\n    ctx.fillText(`Level: ${currentLevel}`, 10, 40);\n    \n    // Draw lives\n    ctx.textAlign = 'right';\n    ctx.fillText(`Lives: ${lives}`, ctx.canvas.width - 10, 20);\n  }, [score, currentLevel, lives]);\n\n  const gameLoop = useCallback((ctx, gameObjects) => {\n    if (!isRunning) return;\n    \n    const currentTime = performance.now();\n    const deltaTime = (currentTime - lastTimeRef.current) / 1000;\n    lastTimeRef.current = currentTime;\n\n    update(ctx, gameObjects, deltaTime);\n    animationFrameIdRef.current = window.requestAnimationFrame(() => gameLoop(ctx, gameObjects));\n  }, [isRunning, update]);\n\n  const start = useCallback((ctx, gameObjects) => {\n    setIsRunning(true);\n    setIsPaused(false);\n    lastTimeRef.current = performance.now();\n    loadLevel(gameObjects);\n    gameLoop(ctx, gameObjects);\n  }, [gameLoop, loadLevel]);\n\n  const stop = useCallback(() => {\n    setIsRunning(false);\n    setIsPaused(false);\n    if (animationFrameIdRef.current) {\n      window.cancelAnimationFrame(animationFrameIdRef.current);\n      animationFrameIdRef.current = null;\n    }\n  }, []);\n\n  const pause = useCallback(() => {\n    setIsPaused(true);\n  }, []);\n\n  const resume = useCallback(() => {\n    setIsPaused(false);\n  }, []);\n\n  return { \n    start, \n    stop, \n    pause,\n    resume,\n    score,\n    currentLevel,\n    lives,\n    isRunning,\n    isPaused,\n    isGameOver,\n    isVictory,\n    setIsRunning,\n    setIsPaused,\n    setIsGameOver,\n    setIsVictory,\n    setCurrentLevel,\n    setScore,\n    setLives,\n    resetGame,\n    loadLevel,\n    handleBallOut\n  };\n};\n\nexport default useGameLoop;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}