{"ast":null,"code":"class Ball {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n    this.radius = 8;\n    this.baseSpeed = 300; // Reduced base speed\n    this.speed = this.baseSpeed;\n    this.dx = 0;\n    this.dy = 0;\n    this.isLaunched = false;\n    this.canvasWidth = 800;\n    this.canvasHeight = 600;\n    this.initialX = x;\n    this.initialY = y;\n    this.lastCollisionTime = 0;\n    this.collisionCooldown = 50; // 50ms cooldown between collisions\n  }\n  draw(ctx) {\n    // Draw glow effect\n    ctx.save();\n    ctx.beginPath();\n    ctx.arc(this.x, this.y, this.radius + 4, 0, Math.PI * 2);\n    ctx.fillStyle = 'rgba(0, 255, 0, 0.2)';\n    ctx.fill();\n    ctx.closePath();\n\n    // Draw outer glow\n    ctx.beginPath();\n    ctx.arc(this.x, this.y, this.radius + 2, 0, Math.PI * 2);\n    ctx.fillStyle = 'rgba(0, 255, 0, 0.4)';\n    ctx.fill();\n    ctx.closePath();\n\n    // Draw main ball\n    ctx.beginPath();\n    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);\n    const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.radius);\n    gradient.addColorStop(0, '#00ff00');\n    gradient.addColorStop(1, '#00cc00');\n    ctx.fillStyle = gradient;\n    ctx.fill();\n\n    // Add highlight\n    ctx.beginPath();\n    ctx.arc(this.x - this.radius / 3, this.y - this.radius / 3, this.radius / 4, 0, Math.PI * 2);\n    ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';\n    ctx.fill();\n    ctx.closePath();\n    ctx.restore();\n  }\n  update(deltaTime) {\n    if (!this.isLaunched) return;\n\n    // Calculate potential new position\n    const newX = this.x + this.dx * deltaTime;\n    const newY = this.y + this.dy * deltaTime;\n\n    // Handle wall collisions with position correction\n    if (newX - this.radius <= 0) {\n      this.x = this.radius;\n      this.dx = Math.abs(this.dx);\n    } else if (newX + this.radius >= this.canvasWidth) {\n      this.x = this.canvasWidth - this.radius;\n      this.dx = -Math.abs(this.dx);\n    } else {\n      this.x = newX;\n    }\n    if (newY - this.radius <= 0) {\n      this.y = this.radius;\n      this.dy = Math.abs(this.dy);\n    } else {\n      this.y = newY;\n    }\n\n    // Normalize speed\n    const currentSpeed = Math.sqrt(this.dx * this.dx + this.dy * this.dy);\n    if (Math.abs(currentSpeed - this.speed) > 0.1) {\n      const speedFactor = this.speed / currentSpeed;\n      this.dx *= speedFactor;\n      this.dy *= speedFactor;\n    }\n  }\n  launch() {\n    if (!this.isLaunched) {\n      this.isLaunched = true;\n      const angle = -Math.PI / 4; // -45 degrees\n      this.dx = this.speed * Math.cos(angle);\n      this.dy = this.speed * Math.sin(angle);\n    }\n  }\n  reset() {\n    this.x = this.initialX;\n    this.y = this.initialY;\n    this.dx = 0;\n    this.dy = 0;\n    this.isLaunched = false;\n    this.speed = this.baseSpeed;\n    this.lastCollisionTime = 0;\n  }\n  stickToPaddle(paddle) {\n    if (!this.isLaunched) {\n      this.x = paddle.x + paddle.width / 2;\n      this.y = paddle.y - this.radius;\n    }\n  }\n  bounceOffPaddle(paddle) {\n    if (!this.isLaunched) return;\n\n    // Calculate relative position of ball hit on paddle\n    const relativeIntersectX = (this.x - (paddle.x + paddle.width / 2)) / (paddle.width / 2);\n\n    // Calculate bounce angle (-60 to 60 degrees)\n    const bounceAngle = relativeIntersectX * Math.PI / 3;\n\n    // Set new velocity with position correction\n    this.dx = this.speed * Math.sin(bounceAngle);\n    this.dy = -Math.abs(this.speed * Math.cos(bounceAngle));\n\n    // Ensure ball is above paddle\n    this.y = paddle.y - this.radius;\n  }\n  bounceOffBrick(brick) {\n    // Check collision cooldown\n    const now = Date.now();\n    if (now - this.lastCollisionTime < this.collisionCooldown) {\n      return false;\n    }\n\n    // Calculate the center points and half dimensions\n    const ballCenterX = this.x;\n    const ballCenterY = this.y;\n    const brickCenterX = brick.x + brick.width / 2;\n    const brickCenterY = brick.y + brick.height / 2;\n    const brickHalfWidth = brick.width / 2;\n    const brickHalfHeight = brick.height / 2;\n\n    // Calculate the difference between centers\n    const dx = ballCenterX - brickCenterX;\n    const dy = ballCenterY - brickCenterY;\n\n    // Calculate overlap on each axis\n    const overlapX = brickHalfWidth + this.radius - Math.abs(dx);\n    const overlapY = brickHalfHeight + this.radius - Math.abs(dy);\n\n    // Position correction and velocity update\n    if (overlapX < overlapY) {\n      // Horizontal collision\n      this.dx = Math.abs(this.dx) * (dx > 0 ? 1 : -1);\n      this.x += dx > 0 ? overlapX : -overlapX;\n    } else {\n      // Vertical collision\n      this.dy = Math.abs(this.dy) * (dy > 0 ? 1 : -1);\n      this.y += dy > 0 ? overlapY : -overlapY;\n    }\n    this.lastCollisionTime = now;\n    return true;\n  }\n  checkPaddleCollision(paddle) {\n    return this.isLaunched && this.x + this.radius > paddle.x && this.x - this.radius < paddle.x + paddle.width && this.y + this.radius > paddle.y && this.y - this.radius < paddle.y + paddle.height;\n  }\n  checkBrickCollision(brick) {\n    if (brick.isDestroyed()) return false;\n\n    // Calculate the closest point on the brick to the ball\n    const closestX = Math.max(brick.x, Math.min(this.x, brick.x + brick.width));\n    const closestY = Math.max(brick.y, Math.min(this.y, brick.y + brick.height));\n\n    // Calculate the distance between the ball's center and this closest point\n    const distanceX = this.x - closestX;\n    const distanceY = this.y - closestY;\n    const distance = Math.sqrt(distanceX * distanceX + distanceY * distanceY);\n\n    // If the distance is less than the ball's radius, collision detected\n    return distance <= this.radius;\n  }\n}\nexport default Ball;","map":{"version":3,"names":["Ball","constructor","x","y","radius","baseSpeed","speed","dx","dy","isLaunched","canvasWidth","canvasHeight","initialX","initialY","lastCollisionTime","collisionCooldown","draw","ctx","save","beginPath","arc","Math","PI","fillStyle","fill","closePath","gradient","createRadialGradient","addColorStop","restore","update","deltaTime","newX","newY","abs","currentSpeed","sqrt","speedFactor","launch","angle","cos","sin","reset","stickToPaddle","paddle","width","bounceOffPaddle","relativeIntersectX","bounceAngle","bounceOffBrick","brick","now","Date","ballCenterX","ballCenterY","brickCenterX","brickCenterY","height","brickHalfWidth","brickHalfHeight","overlapX","overlapY","checkPaddleCollision","checkBrickCollision","isDestroyed","closestX","max","min","closestY","distanceX","distanceY","distance"],"sources":["C:/Users/noahm/OneDrive/Desktop/Coding/brick_blaster2/client/src/components/Game/entities/Ball.js"],"sourcesContent":["class Ball {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n    this.radius = 8;\n    this.baseSpeed = 300; // Reduced base speed\n    this.speed = this.baseSpeed;\n    this.dx = 0;\n    this.dy = 0;\n    this.isLaunched = false;\n    this.canvasWidth = 800;\n    this.canvasHeight = 600;\n    this.initialX = x;\n    this.initialY = y;\n    this.lastCollisionTime = 0;\n    this.collisionCooldown = 50; // 50ms cooldown between collisions\n  }\n\n  draw(ctx) {\n    // Draw glow effect\n    ctx.save();\n    ctx.beginPath();\n    ctx.arc(this.x, this.y, this.radius + 4, 0, Math.PI * 2);\n    ctx.fillStyle = 'rgba(0, 255, 0, 0.2)';\n    ctx.fill();\n    ctx.closePath();\n\n    // Draw outer glow\n    ctx.beginPath();\n    ctx.arc(this.x, this.y, this.radius + 2, 0, Math.PI * 2);\n    ctx.fillStyle = 'rgba(0, 255, 0, 0.4)';\n    ctx.fill();\n    ctx.closePath();\n\n    // Draw main ball\n    ctx.beginPath();\n    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);\n    const gradient = ctx.createRadialGradient(\n      this.x, this.y, 0,\n      this.x, this.y, this.radius\n    );\n    gradient.addColorStop(0, '#00ff00');\n    gradient.addColorStop(1, '#00cc00');\n    ctx.fillStyle = gradient;\n    ctx.fill();\n\n    // Add highlight\n    ctx.beginPath();\n    ctx.arc(this.x - this.radius/3, this.y - this.radius/3, this.radius/4, 0, Math.PI * 2);\n    ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';\n    ctx.fill();\n    ctx.closePath();\n\n    ctx.restore();\n  }\n\n  update(deltaTime) {\n    if (!this.isLaunched) return;\n\n    // Calculate potential new position\n    const newX = this.x + this.dx * deltaTime;\n    const newY = this.y + this.dy * deltaTime;\n\n    // Handle wall collisions with position correction\n    if (newX - this.radius <= 0) {\n      this.x = this.radius;\n      this.dx = Math.abs(this.dx);\n    } else if (newX + this.radius >= this.canvasWidth) {\n      this.x = this.canvasWidth - this.radius;\n      this.dx = -Math.abs(this.dx);\n    } else {\n      this.x = newX;\n    }\n\n    if (newY - this.radius <= 0) {\n      this.y = this.radius;\n      this.dy = Math.abs(this.dy);\n    } else {\n      this.y = newY;\n    }\n\n    // Normalize speed\n    const currentSpeed = Math.sqrt(this.dx * this.dx + this.dy * this.dy);\n    if (Math.abs(currentSpeed - this.speed) > 0.1) {\n      const speedFactor = this.speed / currentSpeed;\n      this.dx *= speedFactor;\n      this.dy *= speedFactor;\n    }\n  }\n\n  launch() {\n    if (!this.isLaunched) {\n      this.isLaunched = true;\n      const angle = -Math.PI / 4; // -45 degrees\n      this.dx = this.speed * Math.cos(angle);\n      this.dy = this.speed * Math.sin(angle);\n    }\n  }\n\n  reset() {\n    this.x = this.initialX;\n    this.y = this.initialY;\n    this.dx = 0;\n    this.dy = 0;\n    this.isLaunched = false;\n    this.speed = this.baseSpeed;\n    this.lastCollisionTime = 0;\n  }\n\n  stickToPaddle(paddle) {\n    if (!this.isLaunched) {\n      this.x = paddle.x + paddle.width / 2;\n      this.y = paddle.y - this.radius;\n    }\n  }\n\n  bounceOffPaddle(paddle) {\n    if (!this.isLaunched) return;\n\n    // Calculate relative position of ball hit on paddle\n    const relativeIntersectX = (this.x - (paddle.x + paddle.width / 2)) / (paddle.width / 2);\n    \n    // Calculate bounce angle (-60 to 60 degrees)\n    const bounceAngle = relativeIntersectX * Math.PI / 3;\n    \n    // Set new velocity with position correction\n    this.dx = this.speed * Math.sin(bounceAngle);\n    this.dy = -Math.abs(this.speed * Math.cos(bounceAngle));\n    \n    // Ensure ball is above paddle\n    this.y = paddle.y - this.radius;\n  }\n\n  bounceOffBrick(brick) {\n    // Check collision cooldown\n    const now = Date.now();\n    if (now - this.lastCollisionTime < this.collisionCooldown) {\n      return false;\n    }\n\n    // Calculate the center points and half dimensions\n    const ballCenterX = this.x;\n    const ballCenterY = this.y;\n    const brickCenterX = brick.x + brick.width / 2;\n    const brickCenterY = brick.y + brick.height / 2;\n    const brickHalfWidth = brick.width / 2;\n    const brickHalfHeight = brick.height / 2;\n\n    // Calculate the difference between centers\n    const dx = ballCenterX - brickCenterX;\n    const dy = ballCenterY - brickCenterY;\n\n    // Calculate overlap on each axis\n    const overlapX = brickHalfWidth + this.radius - Math.abs(dx);\n    const overlapY = brickHalfHeight + this.radius - Math.abs(dy);\n\n    // Position correction and velocity update\n    if (overlapX < overlapY) {\n      // Horizontal collision\n      this.dx = Math.abs(this.dx) * (dx > 0 ? 1 : -1);\n      this.x += dx > 0 ? overlapX : -overlapX;\n    } else {\n      // Vertical collision\n      this.dy = Math.abs(this.dy) * (dy > 0 ? 1 : -1);\n      this.y += dy > 0 ? overlapY : -overlapY;\n    }\n\n    this.lastCollisionTime = now;\n    return true;\n  }\n\n  checkPaddleCollision(paddle) {\n    return (\n      this.isLaunched &&\n      this.x + this.radius > paddle.x &&\n      this.x - this.radius < paddle.x + paddle.width &&\n      this.y + this.radius > paddle.y &&\n      this.y - this.radius < paddle.y + paddle.height\n    );\n  }\n\n  checkBrickCollision(brick) {\n    if (brick.isDestroyed()) return false;\n\n    // Calculate the closest point on the brick to the ball\n    const closestX = Math.max(brick.x, Math.min(this.x, brick.x + brick.width));\n    const closestY = Math.max(brick.y, Math.min(this.y, brick.y + brick.height));\n\n    // Calculate the distance between the ball's center and this closest point\n    const distanceX = this.x - closestX;\n    const distanceY = this.y - closestY;\n    const distance = Math.sqrt(distanceX * distanceX + distanceY * distanceY);\n\n    // If the distance is less than the ball's radius, collision detected\n    return distance <= this.radius;\n  }\n}\n\nexport default Ball;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}