{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useCallback, useRef } from 'react';\nimport LevelManager from './LevelManager';\nexport const useGameLoop = (initialLives = 3) => {\n  _s();\n  const [isRunning, setIsRunning] = useState(false);\n  const [currentLevel, setCurrentLevel] = useState(1);\n  const [score, setScore] = useState(0);\n  const [lives, setLives] = useState(initialLives);\n  const [isGameOver, setIsGameOver] = useState(false);\n  const [isVictory, setIsVictory] = useState(false);\n  const levelManagerRef = useRef(new LevelManager());\n  const animationFrameIdRef = useRef(null);\n  const loadLevel = useCallback(gameObjects => {\n    const levelData = levelManagerRef.current.loadLevel(currentLevel);\n    gameObjects.bricks = levelData.bricks;\n    if (gameObjects.ball) {\n      gameObjects.ball.setSpeed(levelData.speed * 4); // Base speed multiplied by level speed\n    }\n    return levelData;\n  }, [currentLevel]);\n  const resetGame = useCallback(gameObjects => {\n    setCurrentLevel(1);\n    setScore(0);\n    setLives(initialLives);\n    setIsGameOver(false);\n    setIsVictory(false);\n    if (gameObjects.ball) gameObjects.ball.reset();\n    if (gameObjects.paddle) gameObjects.paddle.reset();\n    loadLevel(gameObjects);\n  }, [initialLives, loadLevel]);\n  const handleBallOut = useCallback(gameObjects => {\n    setLives(prev => {\n      const newLives = prev - 1;\n      if (newLives <= 0) {\n        setIsGameOver(true);\n        setIsVictory(false);\n        stop();\n      }\n      return newLives;\n    });\n\n    // Reset ball and paddle position if game isn't over\n    if (lives > 1) {\n      gameObjects.ball.reset();\n      gameObjects.paddle.reset();\n    }\n  }, [lives]);\n  const update = useCallback((ctx, gameObjects) => {\n    const {\n      ball,\n      paddle,\n      bricks = []\n    } = gameObjects;\n\n    // Clear canvas\n    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n\n    // Update game objects\n    ball.update();\n    paddle.update();\n\n    // Check if ball is out\n    if (ball.y + ball.radius > ctx.canvas.height) {\n      handleBallOut(gameObjects);\n      return;\n    }\n\n    // Check paddle collision\n    if (ball.checkCollision(paddle)) {\n      ball.bounceOffPaddle(paddle);\n    }\n\n    // Check brick collisions\n    bricks.forEach((brick, index) => {\n      if (!brick.broken && brick.checkCollision(ball)) {\n        ball.bounceOffBrick(brick);\n        if (brick.hit()) {\n          // Handle brick destruction\n          if (brick.type === 'explosive') {\n            // Destroy adjacent bricks\n            bricks.forEach(otherBrick => {\n              if (!otherBrick.broken && Math.abs(otherBrick.x - brick.x) <= brick.width * 2 && Math.abs(otherBrick.y - brick.y) <= brick.height * 2) {\n                otherBrick.broken = true;\n                setScore(prev => prev + 100);\n              }\n            });\n          }\n          setScore(prev => prev + (brick.type === 'durable' ? 150 : 100));\n        }\n      }\n    });\n\n    // Check if level is complete\n    if (levelManagerRef.current.isLevelComplete(bricks)) {\n      if (currentLevel < levelManagerRef.current.getMaxLevel()) {\n        setCurrentLevel(prev => prev + 1);\n        loadLevel(gameObjects);\n        // Reset ball and paddle position\n        ball.reset();\n        paddle.reset();\n      } else {\n        // Game complete - Victory!\n        setIsGameOver(true);\n        setIsVictory(true);\n        stop();\n      }\n    }\n\n    // Draw game objects\n    bricks.forEach(brick => brick.draw(ctx));\n    ball.draw(ctx);\n    paddle.draw(ctx);\n\n    // Draw HUD\n    drawHUD(ctx);\n  }, [currentLevel, handleBallOut, loadLevel]);\n  const drawHUD = useCallback(ctx => {\n    ctx.font = '16px Arial';\n    ctx.fillStyle = '#FFFFFF';\n    ctx.textAlign = 'left';\n    ctx.fillText(`Score: ${score}`, 10, 20);\n    ctx.fillText(`Level: ${currentLevel}`, 10, 40);\n\n    // Draw lives\n    ctx.textAlign = 'right';\n    ctx.fillText(`Lives: ${lives}`, ctx.canvas.width - 10, 20);\n  }, [score, currentLevel, lives]);\n  const gameLoop = useCallback((ctx, gameObjects) => {\n    if (!isRunning) return;\n    update(ctx, gameObjects);\n    animationFrameIdRef.current = window.requestAnimationFrame(() => gameLoop(ctx, gameObjects));\n  }, [isRunning, update]);\n  const start = useCallback((ctx, gameObjects) => {\n    setIsRunning(true);\n    loadLevel(gameObjects);\n    gameLoop(ctx, gameObjects);\n  }, [gameLoop, loadLevel]);\n  const stop = useCallback(() => {\n    setIsRunning(false);\n    if (animationFrameIdRef.current) {\n      window.cancelAnimationFrame(animationFrameIdRef.current);\n    }\n  }, []);\n  return {\n    start,\n    stop,\n    score,\n    currentLevel,\n    lives,\n    isRunning,\n    isGameOver,\n    isVictory,\n    resetGame\n  };\n};\n_s(useGameLoop, \"5uJyqkUTQpplToBEEvlGoUqJnOc=\");\nexport default useGameLoop;","map":{"version":3,"names":["useState","useCallback","useRef","LevelManager","useGameLoop","initialLives","_s","isRunning","setIsRunning","currentLevel","setCurrentLevel","score","setScore","lives","setLives","isGameOver","setIsGameOver","isVictory","setIsVictory","levelManagerRef","animationFrameIdRef","loadLevel","gameObjects","levelData","current","bricks","ball","setSpeed","speed","resetGame","reset","paddle","handleBallOut","prev","newLives","stop","update","ctx","clearRect","canvas","width","height","y","radius","checkCollision","bounceOffPaddle","forEach","brick","index","broken","bounceOffBrick","hit","type","otherBrick","Math","abs","x","isLevelComplete","getMaxLevel","draw","drawHUD","font","fillStyle","textAlign","fillText","gameLoop","window","requestAnimationFrame","start","cancelAnimationFrame"],"sources":["c:/Users/noahm/OneDrive/Desktop/Coding/brick_blaster2/client/src/components/Game/GameLoop.js"],"sourcesContent":["import { useState, useCallback, useRef } from 'react';\nimport LevelManager from './LevelManager';\n\nexport const useGameLoop = (initialLives = 3) => {\n  const [isRunning, setIsRunning] = useState(false);\n  const [currentLevel, setCurrentLevel] = useState(1);\n  const [score, setScore] = useState(0);\n  const [lives, setLives] = useState(initialLives);\n  const [isGameOver, setIsGameOver] = useState(false);\n  const [isVictory, setIsVictory] = useState(false);\n  const levelManagerRef = useRef(new LevelManager());\n  const animationFrameIdRef = useRef(null);\n\n  const loadLevel = useCallback((gameObjects) => {\n    const levelData = levelManagerRef.current.loadLevel(currentLevel);\n    gameObjects.bricks = levelData.bricks;\n    if (gameObjects.ball) {\n      gameObjects.ball.setSpeed(levelData.speed * 4); // Base speed multiplied by level speed\n    }\n    return levelData;\n  }, [currentLevel]);\n\n  const resetGame = useCallback((gameObjects) => {\n    setCurrentLevel(1);\n    setScore(0);\n    setLives(initialLives);\n    setIsGameOver(false);\n    setIsVictory(false);\n    if (gameObjects.ball) gameObjects.ball.reset();\n    if (gameObjects.paddle) gameObjects.paddle.reset();\n    loadLevel(gameObjects);\n  }, [initialLives, loadLevel]);\n\n  const handleBallOut = useCallback((gameObjects) => {\n    setLives(prev => {\n      const newLives = prev - 1;\n      if (newLives <= 0) {\n        setIsGameOver(true);\n        setIsVictory(false);\n        stop();\n      }\n      return newLives;\n    });\n\n    // Reset ball and paddle position if game isn't over\n    if (lives > 1) {\n      gameObjects.ball.reset();\n      gameObjects.paddle.reset();\n    }\n  }, [lives]);\n\n  const update = useCallback((ctx, gameObjects) => {\n    const { ball, paddle, bricks = [] } = gameObjects;\n    \n    // Clear canvas\n    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n    \n    // Update game objects\n    ball.update();\n    paddle.update();\n    \n    // Check if ball is out\n    if (ball.y + ball.radius > ctx.canvas.height) {\n      handleBallOut(gameObjects);\n      return;\n    }\n    \n    // Check paddle collision\n    if (ball.checkCollision(paddle)) {\n      ball.bounceOffPaddle(paddle);\n    }\n\n    // Check brick collisions\n    bricks.forEach((brick, index) => {\n      if (!brick.broken && brick.checkCollision(ball)) {\n        ball.bounceOffBrick(brick);\n        if (brick.hit()) {\n          // Handle brick destruction\n          if (brick.type === 'explosive') {\n            // Destroy adjacent bricks\n            bricks.forEach(otherBrick => {\n              if (!otherBrick.broken && \n                  Math.abs(otherBrick.x - brick.x) <= brick.width * 2 && \n                  Math.abs(otherBrick.y - brick.y) <= brick.height * 2) {\n                otherBrick.broken = true;\n                setScore(prev => prev + 100);\n              }\n            });\n          }\n          setScore(prev => prev + (brick.type === 'durable' ? 150 : 100));\n        }\n      }\n    });\n    \n    // Check if level is complete\n    if (levelManagerRef.current.isLevelComplete(bricks)) {\n      if (currentLevel < levelManagerRef.current.getMaxLevel()) {\n        setCurrentLevel(prev => prev + 1);\n        loadLevel(gameObjects);\n        // Reset ball and paddle position\n        ball.reset();\n        paddle.reset();\n      } else {\n        // Game complete - Victory!\n        setIsGameOver(true);\n        setIsVictory(true);\n        stop();\n      }\n    }\n    \n    // Draw game objects\n    bricks.forEach(brick => brick.draw(ctx));\n    ball.draw(ctx);\n    paddle.draw(ctx);\n\n    // Draw HUD\n    drawHUD(ctx);\n  }, [currentLevel, handleBallOut, loadLevel]);\n\n  const drawHUD = useCallback((ctx) => {\n    ctx.font = '16px Arial';\n    ctx.fillStyle = '#FFFFFF';\n    ctx.textAlign = 'left';\n    ctx.fillText(`Score: ${score}`, 10, 20);\n    ctx.fillText(`Level: ${currentLevel}`, 10, 40);\n    \n    // Draw lives\n    ctx.textAlign = 'right';\n    ctx.fillText(`Lives: ${lives}`, ctx.canvas.width - 10, 20);\n  }, [score, currentLevel, lives]);\n\n  const gameLoop = useCallback((ctx, gameObjects) => {\n    if (!isRunning) return;\n    \n    update(ctx, gameObjects);\n    animationFrameIdRef.current = window.requestAnimationFrame(() => gameLoop(ctx, gameObjects));\n  }, [isRunning, update]);\n\n  const start = useCallback((ctx, gameObjects) => {\n    setIsRunning(true);\n    loadLevel(gameObjects);\n    gameLoop(ctx, gameObjects);\n  }, [gameLoop, loadLevel]);\n\n  const stop = useCallback(() => {\n    setIsRunning(false);\n    if (animationFrameIdRef.current) {\n      window.cancelAnimationFrame(animationFrameIdRef.current);\n    }\n  }, []);\n\n  return { \n    start, \n    stop, \n    score,\n    currentLevel,\n    lives,\n    isRunning,\n    isGameOver,\n    isVictory,\n    resetGame\n  };\n};\n\nexport default useGameLoop;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}